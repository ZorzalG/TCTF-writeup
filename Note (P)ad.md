## Question
> I'm learning about RSA, but these numbers are too big for me to remember them. Let me write some of them down so I only need to remember one. https://en.wikipedia.org/wiki/RSA_(cryptosystem)

gen.py
```
from Crypto.Util.number import *
import random

flag = open('flag.txt','rb').read()
plaintext = bytes_to_long(flag)

p = getPrime(512)
q = getPrime(512)
n = p*q
e = 65537

ciphertext = pow(plaintext,e,n)

print("n =",n)
print("p =",p)
print("e =",e)
print("c =",ciphertext)
```

output.txt
```
n = 115119926916175292443993358628119432500511457411851215469790810846720872098623052936190735504066034404312920281689086421832339183729557342035276299909252599534671537210755795876458420578465359242960881126071384044972606812099610973502962833559594213985731512360343897443261448949469357794038005043540400372219
p = 8853781923533925846329999902184220480466011310340330790793373629057560797650761771956175465040246482461917551952941015380725586165982310398940423902844501
e = 65537
c = 41990830753623471604136246638419587866057180506266765431679440642717897872522396014165074048656019385418709181001765568774665247497146530489691877836367730532150868942720164820406799948636401180665912900249857339991811483181944270892990458104642253546843305509033906516101751311151600290393067525492902269115
```

## Solution

The RSA algorithm works based on the equation: ```c^d = m (mod n)```.
```d``` is calculated as the modular multiplicative inverse of ```e```, or ```d*e=1 (mod λ(n))```. From the Wikipedia page, we learn that ```λ(n)``` is equal to ```lcm((p-1)*(q-1))```. Since we're given ```p``` in the output, we can also easily calculate ```q```, and subsequently ```λ(n), d, and m```.

Code:
```
from Crypto.Util.number import *
import math
n = 115119926916175292443993358628119432500511457411851215469790810846720872098623052936190735504066034404312920281689086421832339183729557342035276299909252599534671537210755795876458420578465359242960881126071384044972606812099610973502962833559594213985731512360343897443261448949469357794038005043540400372219
p = 8853781923533925846329999902184220480466011310340330790793373629057560797650761771956175465040246482461917551952941015380725586165982310398940423902844501
e = 65537
c = 41990830753623471604136246638419587866057180506266765431679440642717897872522396014165074048656019385418709181001765568774665247497146530489691877836367730532150868942720164820406799948636401180665912900249857339991811483181944270892990458104642253546843305509033906516101751311151600290393067525492902269115

q = n//p

d = pow(e,-1,math.lcm((q-1)*(p-1)))

print(long_to_bytes(pow(c,d,n)))
```
Note: the method ```long_to_bytes``` simply takes a decimal number, and converts it to a hexadecimal string of ASCII characters.

The flag is ```T{cr4p...w4s_i_n0t_supp0s3d_t0_sh0w_y0u_th4t?}```
